# this file is generated by copilot, kept for the future purposes. 

import unittest
import numpy as np
import jax.numpy as jnp


# import the function under test
from ..plots_and_scenario_generators.random_scenarios_generator import random_scenario

class TestRandomScenario(unittest.TestCase):

    def setUp(self):
        self.n_ap = 4
        self.n_sta_per_ap = 10
        self.seed = 42

        self.associations, self.pos, self.tx = random_scenario(
            n_ap=self.n_ap,
            n_sta_per_ap=self.n_sta_per_ap,
            seed=self.seed,
        )

        self.n_nodes = self.n_ap + self.n_ap * self.n_sta_per_ap

    # ---------- Associations tests ----------

    def test_associations_structure(self):
        """Each AP should map to exactly n_sta_per_ap STAs"""
        self.assertEqual(len(self.associations), self.n_ap)

        for ap, stas in self.associations.items():
            self.assertEqual(len(stas), self.n_sta_per_ap)
            self.assertTrue(all(isinstance(s, int) for s in stas))

    def test_associations_ranges(self):
        """STA indices should be valid and non-overlapping"""
        all_stas = []

        for ap, stas in self.associations.items():
            for sta in stas:
                self.assertGreaterEqual(sta, self.n_ap)
                self.assertLess(sta, self.n_nodes)
            all_stas.extend(stas)

        self.assertEqual(len(set(all_stas)), len(all_stas))

    # ---------- Position tests ----------

    def test_positions_shape(self):
        """Position array should be (n_nodes, 2)"""
        self.assertEqual(self.pos.shape, (self.n_nodes, 2))

    def test_ap_positions_count(self):
        """First n_ap positions correspond to APs"""
        ap_pos = self.pos[:self.n_ap]
        self.assertEqual(ap_pos.shape, (self.n_ap, 2))

    def test_sta_positions_count(self):
        """Remaining positions correspond to STAs"""
        sta_pos = self.pos[self.n_ap:]
        expected_sta_count = self.n_ap * self.n_sta_per_ap
        self.assertEqual(sta_pos.shape, (expected_sta_count, 2))

    # ---------- TX matrix tests ----------

    def test_tx_shape(self):
        """TX matrix should be square (n_nodes, n_nodes)"""
        self.assertEqual(self.tx.shape, (self.n_nodes, self.n_nodes))

    def test_tx_values_binary(self):
        """TX should contain only 0 or 1"""
        unique_vals = jnp.unique(self.tx)
        self.assertTrue(set(unique_vals.tolist()).issubset({0, 1}))

    def test_tx_one_sta_per_ap(self):
        """Each AP should transmit to exactly one STA"""
        tx_np = np.array(self.tx)

        for ap in range(self.n_ap):
            self.assertEqual(tx_np[ap].sum(), 1)

    def test_tx_only_ap_rows_active(self):
        """Only AP rows should have transmissions"""
        tx_np = np.array(self.tx)

        for node in range(self.n_ap, self.n_nodes):
            self.assertEqual(tx_np[node].sum(), 0)

    def test_tx_targets_valid_sta(self):
        """TX targets must be valid STA indices for each AP"""
        tx_np = np.array(self.tx)

        for ap in range(self.n_ap):
            sta_idx = tx_np[ap].nonzero()[0][0]
            self.assertIn(sta_idx, self.associations[ap])

    # ---------- Determinism tests ----------

    def test_seed_determinism(self):
        """Same seed should produce identical outputs"""
        _, pos2, tx2 = random_scenario(
            n_ap=self.n_ap,
            n_sta_per_ap=self.n_sta_per_ap,
            seed=self.seed,
        )

        np.testing.assert_allclose(self.pos, pos2)
        np.testing.assert_array_equal(self.tx, tx2)


if __name__ == "__main__":
    unittest.main()


